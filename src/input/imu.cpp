/*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015-2017 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "imu.h"
#include <Limelight.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>

#include <wiringPi.h>
#include "RTIMULib.h"

#include <pthread.h>

//#include "rtimu.h"

#define PINL 14
#define PINR 4

#define IMU_RETURN 1
#define IMU_OK 0

//static rtimu_t *imu;
RTIMU *imu;

float prevYaw = 0.0;
float prevPitch= 0.0;

float yaw = 0.0;
float pitch = 0.0;

int buttonL = 0;
int buttonR = 0;

int movX;
int movY;

int currentX = 0;
int currentY = 0;

static bool (*handler) ();

static void evdev_remove(int devindex) {
  fprintf(stderr, "Removed imu device\n");
}

static bool imu_handle_event() {  
  RTIMU_DATA imuData = imu->getIMUData();
  yaw = imuData.fusionPose.z();
  pitch = imuData.fusionPose.y();
  movX = ( prevYaw - imuData.fusionPose.z() ) * 4000;
  movY = ( prevPitch - imuData.fusionPose.y() ) * 4000;

  prevYaw = imuData.fusionPose.z();
  prevPitch = imuData.fusionPose.y();

  int sensX = 1;
  int sensY = 1;

  currentX = (movX*sensX);
  currentY = (movY*sensY);

  printf("\n (x, y): (%f, %f)", yaw, pitch);

  LiSendMouseMoveEvent(currentX, currentY);

  int tbuttonL = !digitalRead(PINL);
	int tbuttonR = !digitalRead(PINR);
  
  int mouseCode = 0;      
  int value;
  if(buttonL != tbuttonL) {
    mouseCode = BUTTON_LEFT;
    value = tbuttonL;
    buttonL = tbuttonL;
  } else if(buttonR != tbuttonR) {
    mouseCode = BUTTON_RIGHT;
    value = tbuttonR;
    buttonR = tbuttonR;
  }

  if (mouseCode != 0) {
    LiSendMouseButtonEvent(value?BUTTON_ACTION_PRESS:BUTTON_ACTION_RELEASE, mouseCode);
  }

  return true;
}

static void imu_drain(void) {
  //pass
}

static int imu_handle() {
  //if(rtimu_read(imu)) {
  while(imu->IMURead()) {
      if (!handler()) {
        return IMU_RETURN;
      }
      usleep(1 * 1000);
            
  }

  return IMU_OK;
}

void imu_create(const char* device, struct mapping* mappings, bool verbose) {
  buttonL = false;
  buttonR = false;

  wiringPiSetupGpio();
  pullUpDnControl(PINL,PUD_UP);
  pullUpDnControl(PINR,PUD_UP);

  if(verbose) {
    printf("Wiring Setup\n");
  }		
  
  //Init MPU stuffs

  uint64_t rateTimer;
  uint64_t displayTimer;
  uint64_t now;

  //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
  //  Or, you can create the .ini in some other directory by using:
  //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
  //  where <directory path> is the path to where the .ini file is to be loaded/saved
 
  RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

  imu = RTIMU::createIMU(settings);

  if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
      printf("No IMU found\n");
      return;
  }

  //  This is an opportunity to manually override any settings before the call IMUInit

  //  set up IMU

  imu->IMUInit();

  //  this is a convenient place to change fusion parameters

  imu->setSlerpPower(0.02);
  imu->setGyroEnable(true);
  imu->setAccelEnable(true);
  imu->setCompassEnable(false);


  //  set up for rate timer

  //rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();  
}

void *imu_loop(void *unused) {
  while(TRUE) {
    int ret = imu_handle();
    if (ret == IMU_RETURN) {
      break;
    }
  }
}

void imu_start() {
  // Start rendering
  pthread_t thread1;
  pthread_create(&thread1, NULL, imu_loop, NULL);
}

void imu_stop() {
  imu_drain();
}

void imu_init() {
  handler = imu_handle_event;
}
