/*
 * This file is part of Moonlight Embedded.
 *
 * Copyright (C) 2015-2017 Iwan Timmer
 *
 * Moonlight is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Moonlight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Moonlight; if not, see <http://www.gnu.org/licenses/>.
 */

#include "imu.h"

#include "keyboard.h"

#include "../loop.h"
#include "libevdev/libevdev.h"

#include <Limelight.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <fcntl.h>
#include <poll.h>
#include <limits.h>
#include <unistd.h>
#include <pthread.h>
#include <endian.h>

#include <wiringPi.h>

#include "rtimu.h"

#define PINL 14
#define PINR 4

static rtimu_t *imu;

float prevYaw;
float prevPitch;

float yaw;
float pitch;

int buttonL = 0;
int buttonR = 0;

int movX;
int movY;

int currentX = 1280 / 2;
int currentY = 720 / 2;


struct input_abs_parms {
  int min, max;
  int flat;
  int avg;
  int range, diff;
};

struct input_device {
  struct libevdev *dev;
  struct mapping* map;
  int key_map[KEY_MAX];
  int abs_map[ABS_MAX];
  int hats_state[3][2];
  int fd;
  char modifiers;
  __s32 mouseDeltaX, mouseDeltaY, mouseScroll;
  short controllerId;
  int buttonFlags;
  char leftTrigger, rightTrigger;
  short leftStickX, leftStickY;
  short rightStickX, rightStickY;
  bool gamepadModified;
  struct input_abs_parms xParms, yParms, rxParms, ryParms, zParms, rzParms;
};

static bool (*handler) (struct input_event*, struct input_device*);

static void evdev_remove(int devindex) {
  fprintf(stderr, "Removed imu device\n");
}

static bool imu_handle_event(struct input_event *ev, struct input_device *dev) {
  //RTIMU_DATA imuData = imu->rtimu_get_IMUData();
  yaw = rtimu_get_fusionPose_z(imu);
  pitch = rtimu_get_fusionPose_y(imu);
  movX = ( prevYaw - rtimu_get_fusionPose_z(imu) ) * 4000;
  movY = ( prevPitch - rtimu_get_fusionPose_y(imu) ) * 4000;

  prevYaw = rtimu_get_fusionPose_z(imu);
  prevPitch = rtimu_get_fusionPose_y(imu);

  int sensX = 1.0;
  int sensY = 1.0;

  currentX = currentX-(movX*sensX);
  currentY = currentY-(movY*sensY);

  LiSendMouseMoveEvent(currentX, currentY);

  int tbuttonL = !digitalRead(PINL);
	int tbuttonR = !digitalRead(PINR);
  
  int mouseCode = 0;      
  int value;
  if(buttonL != tbuttonL) {
    mouseCode = BUTTON_LEFT;
    value = tbuttonL;
    buttonL = tbuttonL;
  } else if(buttonR != tbuttonR) {
    mouseCode = BUTTON_RIGHT;
    value = tbuttonR;
    buttonR = tbuttonR;
  }

  if (mouseCode != 0) {
    LiSendMouseButtonEvent(value?BUTTON_ACTION_PRESS:BUTTON_ACTION_RELEASE, mouseCode);
  }

  return true;
}

static void imu_drain(void) {
  //pass
}

static int imu_handle(int fd) {
  if(rtimu_read(imu)) {
    if (!handler(NULL, NULL)) {
      return LOOP_RETURN;
    }
            
  }

  return LOOP_OK;
}

void imu_create(const char* device, struct mapping* mappings, bool verbose) {
  buttonL = false;
  buttonR = false;

  wiringPiSetupGpio();
  pullUpDnControl(PINL,PUD_UP);
  pullUpDnControl(PINR,PUD_UP);

  if(verbose) {
    printf("Wiring Setup\n");
  }		
  
  //Init MPU stuffs

  uint64_t rateTimer;
  uint64_t displayTimer;
  uint64_t now;

  //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
  //  Or, you can create the .ini in some other directory by using:
  //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
  //  where <directory path> is the path to where the .ini file is to be loaded/saved

  rtimu_settings_t settings = rtimu_settings_new("RTIMULib");

  imu = rtimu_createIMU(settings);

  if ((imu == NULL) || rtimu_type_is_null(imu)) {
      printf("No IMU found\n");
      return;
  }

  //  This is an opportunity to manually override any settings before the call IMUInit

  //  set up IMU

  rtimu_init(imu);

  //  this is a convenient place to change fusion parameters

  rtimu_set_slerp_power(0.02);
  rtimu_set_gyro_enable(true);
  rtimu_set_accel_enable(true);
  rtimu_set_compass_enable(false);

  //  set up for rate timer

  //rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();
   
  int fd = 66;
  loop_add_fd(fd, &imu_handle, POLLIN);
}

void imu_start() {
  // After grabbing, the only way to quit via the keyboard
  // is via the special key combo that the input handling
  // code looks for. For this reason, we wait to grab until
  // we're ready to take input events. Ctrl+C works up until
  // this point.
  
  // Any new input devices detected after this point will be grabbed immediately
  //grabbingDevices = true;

  // Handle input events until the quit combo is pressed
}

void imu_stop() {
  imu_drain();
}

void imu_init() {
  handler = imu_handle_event;
}
